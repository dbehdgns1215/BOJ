#include <bits/stdc++.h>
using namespace std;

vector<long long> x1; // 정렬할 벡터
vector<long long> x2; // 원본 벡터
int n;
int temp;

int main() {
	ios::sync_with_stdio(false);
	cin.tie(nullptr);

	cin >> n;
	for (int i = 0; i < n; i++)
	{
		cin >> temp;
		x1.push_back(temp);
		x2.push_back(temp);
	}
	sort(x1.begin(), x1.end());
	// sort를 통해서 오름차순으로 벡터를 정렬.
	x1.erase(unique(x1.begin(), x1.end()), x1.end());
	// unique 함수는 중복되는 값들을 제일 뒤로 보내버리는 것.
	// 예를 들어 1, 2, 2, 3, 4, 4, 5 라는 배열이 있다면
	// unique 함수를 적용시키면 1, 2, 3, 4, 5, 2, 4 처럼 중복되는 2와 4가 뒤로 이동하게 된다.
	// 그리고 unique 함수는 첫 번째로 이동시킨 함수의 위치를 저장하는 반복자를 반환해주기에
	// erase 함수로 중복시작 -> end() 로 중복되는 값들을 완전히 지워주는 것.

	for (int i = 0; i < n; i++) {
		cout << lower_bound(x1.begin(), x1.end(), x2[i]) - x1.begin() << " ";
		// lower_bound는 특정 구간에서 찾고자 하는 값 이상이 처음으로 나타나는 위치의 반복자를 반환해줌.
		// 그 상태에서 x1.begin()을 빼주는 이유는 반환자 끼리의 거리를 구해주는 것과 같은 맥락.
		/*
		예를 들어, vector<int> v = {10, 20, 30, 40, 50};이라는 벡터가 있을 때, v.begin()은 첫 번째 원소인 10을 가리키는 반복자를 반환하게 됩니다. 이 반복자가 실제로 어떻게 생겼는지를 확인하는 것은 실질적으로 불가능합니다. 왜냐하면 반복자는 내부적으로 컨테이너의 구현에 따라 다르게 표현되기 때문입니다. 우리가 알 수 있는 것은 그 반복자가 어떤 원소를 가리키고 있는지 뿐입니다.

lower_bound(v.begin(), v.end(), 20)을 호출하면, 20 이상 값이 처음으로 나타나는 위치를 가리키는 반복자를 반환하게 됩니다. 여기서는 20을 가리키는 반복자가 됩니다.

이제 여기서 v.begin()을 빼면, 20을 가리키는 반복자에서 10을 가리키는 반복자까지의 "거리"를 구하게 됩니다. 이 "거리"는 실제 물리적인 거리가 아니라, 첫 번째 원소부터 해당 원소까지 몇 개의 원소가 있는지를 나타냅니다. 즉, 이 거리는 20이 첫 번째 원소로부터 두 번째 원소라는 것을 나타내므로, 값은 1이 됩니다.

따라서 lower_bound()의 반환값에서 begin()을 빼는 것은, 찾고자 하는 값이 첫 번째 원소로부터 몇 번째에 위치하는지를 알아내는 것과 같습니다. 이 값이 바로 해당 숫자의 새로운 값이 됩니다.
		*/
	}
}